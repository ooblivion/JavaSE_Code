### 设计模式概述
- 设计模式的概念：一套被反复使用，前人经验总结的代码，具有一定的普遍性

- 学习设计模式的必要性
    - 面向对象思想的巩固
    - 对类的封装性，继承性和多态性以及类的关联关系和组合关系的深入理解
    - 使代码的可重用性更高，可读性高，可靠性高，灵活性好，可维护性强
    - 提高编程效率，缩短开发周期

- 设计模式分类
    - 创建性模式：
        - 用于描述如何创建对象，特点是将创建与使用分离（解耦）
        - 单例，原型，工厂方法，抽象工厂，建造者
    - 结构性模式：
        - 用于描述如何将类或对象按某种布局组合成更大的结构
        - 享元，代理，外观，桥接，组合，装饰者，适配器
    - 行为型模式：
        - 用于描述类或对象之间怎样相互协作共同完成单个对象无法完成的任务，以及怎样分配职责的
        - 中介者，命令，备忘录，模板方法，状态，策略，职责链，观察者，解释器，访问者，迭代器  
    - 举例：假设要盖一个房子，创建型就是去买房子的材料，结构型就是将这些材料组装



### UML图
#### 概念及作用
- UML种类： 
    - 例图，类图，对象图，状态图，活动图，时序图，协作图，构建图，部署图
- 类图概述
    - 显示模型的静态结构，特别是模型中存在的类，类的内部结构以及他们与其他类之间的关系。
- 类图的作用
    - 类图是一种静态的结构图，描述了系统的类的集合，类的属性和类之间的关系，可以简化对系统的理解
    - 类图是系统设计和分析阶段的产物，是系统的编码和测试的重要模型
#### 类图表示
- 类图的表示方式
    - 类名，成员变量（属性），成员方法
    - 成员变量前面 +public -private #protected
    - 属性的完整表示方式：
        - `可见性 名称 : 类型 [ = 初始化值/缺省值]`
        - `- address : String = "Earth"`
    - 方法的完整表示方式： 
        - `可见性 名称(参数列表) [ : 返回类型]`
        - `# method_name(int par1, Stirng par2) : int` 
- 类之间的关系
    - 关联
      - 定义：对象之间的引用，用于表示一个类和另外一个类之间的关系，比如一个老师要教多个学生
      - 单向关联 `Customer (- address Address) -> Address`
      - 双向关联 `Customer (- products: List<Product>) - Product(- Customer customer)`
      - 关联 
    - 聚合
      - 定义：聚合关系是关联关系的一种非，是强关联关系，是整体和部分之间的关系（比如学校和老师
      - `University (- teas : List<Teacher>) <>- Teacher(- name : String | + teach() : void)`
    - 组合
      - 定义：依然是整体和部分之间的关系，但是是一种更强的聚合关系，整体对象可以控制部分对象那的生命周期，一旦整体不存在，对象也会消失
      - `Head(- mouth : Mouth) <>- Mouth(- eat() : void)`
    - 依赖⭐
      - 定义：依赖是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联，在代码中通过局部变量，方法的参数或者对静态方法的调用来访问另外一个类（被依赖类）中的某个方法来完成一些职责
      - `Driver(- name : String | + drrive(Car car) : void) ---> Car(+ move() : void)`
      - `public void diive(Car car){car.move();}`
    - 继承 extend
      - 定义：是对象耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系是一种继承关系
      - 实心空心三角箭头从子类指向父类
    - 实现 implement
      - 虚线空心三角箭头
    
- 从变量的角度
    - 区分依赖和关联：依赖是局部变量，关联是全局变量 
    - 区分组组合和聚合：组合是用构造方法注入，聚合是用Set方法或其他方法注入

### 软件设计原则
#### 开闭原则
- 对扩展开放，对修改关闭
- 对程序扩展的时候不能修改原有代码，实现一个热插拔效果，为了使程序的扩展性更好，易于维护和升级
- 如何实现该效果
    - 使用接口和抽象类
#### 里氏替换原则
- 任何父类可以出现的地方，子类一定可以出现
- 通俗理解，子类可以扩展父类的功能，但不能改变不父类原有的功能。换句话说，子类继承父类的时候，除添加新的方法完成新的功能之外，尽量不要重写父类的方法
- 重写父类的方法会导致整个继承体系的复用性比较差，特别是运用多态比较频繁时，程序运行出错的概率比较大
#### 依赖倒转原则
#### 接口隔离原则
#### 迪米特法则/单一职责原则
#### 合成复用原则

