### 设计模式概述
- 设计模式的概念：一套被反复使用，前人经验总结的代码，具有一定的普遍性

- 学习设计模式的必要性
    - 面向对象思想的巩固
    - 对类的封装性，继承性和多态性以及类的关联关系和组合关系的深入理解
    - 使代码的可重用性更高，可读性高，可靠性高，灵活性好，可维护性强
    - 提高编程效率，缩短开发周期

- 设计模式分类
    - 创建性模式：
        - 用于描述如何创建对象，特点是将创建与使用分离（解耦）
        - 单例，原型，工厂方法，抽象工厂，建造者
    - 结构性模式：
        - 用于描述如何将类或对象按某种布局组合成更大的结构
        - 享元，代理，外观，桥接，组合，装饰者，适配器
    - 行为型模式：
        - 用于描述类或对象之间怎样相互协作共同完成单个对象无法完成的任务，以及怎样分配职责的
        - 中介者，命令，备忘录，模板方法，状态，策略，职责链，观察者，解释器，访问者，迭代器  
    - 举例：假设要盖一个房子，创建型就是去买房子的材料，结构型就是将这些材料组装

### UML图
#### 概念及作用
- UML种类： 
    - 例图，类图，对象图，状态图，活动图，时序图，协作图，构建图，部署图
- 类图概述
    - 显示模型的静态结构，特别是模型中存在的类，类的内部结构以及他们与其他类之间的关系。
- 类图的作用
    - 类图是一种静态的结构图，描述了系统的类的集合，类的属性和类之间的关系，可以简化对系统的理解
    - 类图是系统设计和分析阶段的产物，是系统的编码和测试的重要模型
#### 类图表示
- 类图的表示方式
    - 类名，成员变量（属性），成员方法
    - 成员变量前面 +public -private #protected
    - 属性的完整表示方式：
        - `可见性 名称 : 类型 [ = 初始化值/缺省值]`
        - `- address : String = "Earth"`
    - 方法的完整表示方式： 
        - `可见性 名称(参数列表) [ : 返回类型]`
        - `# method_name(int par1, Stirng par2) : int` 
- 类之间的关系
    - 关联
      - 定义：对象之间的引用，用于表示一个类和另外一个类之间的关系，比如一个老师要教多个学生
      - 单向关联 `Customer (- address Address) -> Address`
      - 双向关联 `Customer (- products: List<Product>) - Product(- Customer customer)`
      - 关联 
    - 聚合
      - 定义：聚合关系是关联关系的一种非，是强关联关系，是整体和部分之间的关系（比如学校和老师
      - `University (- teas : List<Teacher>) <>- Teacher(- name : String | + teach() : void)`
    - 组合
      - 定义：依然是整体和部分之间的关系，但是是一种更强的聚合关系，整体对象可以控制部分对象那的生命周期，一旦整体不存在，对象也会消失
      - `Head(- mouth : Mouth) <>- Mouth(- eat() : void)`
    - 依赖⭐
      - 定义：依赖是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联，在代码中通过局部变量，方法的参数或者对静态方法的调用来访问另外一个类（被依赖类）中的某个方法来完成一些职责
      - `Driver(- name : String | + drrive(Car car) : void) ---> Car(+ move() : void)`
      - `public void diive(Car car){car.move();}`
    - 继承 extend
      - 定义：是对象耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系是一种继承关系
      - 实心空心三角箭头从子类指向父类
    - 实现 implement
      - 虚线空心三角箭头
    
- 从变量的角度
    - 区分依赖和关联：依赖是局部变量，关联是全局变量 
    - 区分组组合和聚合：组合是用构造方法注入，聚合是用Set方法或其他方法注入

### 软件设计原则
#### 开闭原则
- 对扩展开放，对修改关闭
- 对程序扩展的时候不能修改原有代码，实现一个热插拔效果，为了使程序的扩展性更好，易于维护和升级
- 如何实现该效果
    - 使用接口和抽象类
- 案例：搜狗输入法的皮肤设计
    - 分析：搜狗输入法的皮肤是输入法背景图片，窗口颜色和声音等元素的组合。用户可以根据自己的喜爱更换自己的输入法的皮肤，也可以从 网上下载的新皮肤，这些皮肤有共同的特点，可以为其定义一个抽象类（AbstractSkin），而每个具体的皮肤（DefaultSpecificSkin）和（HeimaSpecificSkin）是其子类。用户窗体可以根据需要选择或者增加新的主题，而不需要需改原代码，所以它满足开闭原则。
#### 里氏替换原则
- 任何父类可以出现的地方，子类一定可以出现
- 通俗理解，子类可以扩展父类的功能，但不能改变不父类原有的功能。换句话说，子类继承父类的时候，除添加新的方法完成新的功能之外，尽量不要重写父类的方法
- 重写父类的方法会导致整个继承体系的复用性比较差，特别是运用多态比较频繁时，程序运行出错的概率比较大
- 案例：正方形不是长方形
    - 分析：在数学领域里，正方形毫无疑问是长方形，它是一个长宽相等的长方形，所以我们开发的一个与几何图形相关的软件系统，就可以顺理成章的让正方形继承自长方形。
    - 问题：假如我们把一个普通长方形作为参数传入resize方法，就会看到长方形宽度逐渐增长的现象，当宽度大于长度，代码就会停止，这种行为的结果符合我们的预期；假如我们再把一个正方形作为参数传入resize方法后，就会看到正方形的宽度和长度都在不断增长。代码会一直运行下去，直至系统产生溢出错误。所以，普通的长方形是适合这段代码的，正方形不适合。
    - 结论：再resize方法中，Rectangle类型的参数不能被Square类型的参数所代替，如果进行了替换就得不到预期结果。因此，Square类和Rectangle类之间的继承关系违反了里氏代换原则，它们之间的继承关系不成立，正方形不是长方形。
    - 改进：此时我们需要重新设计它们之间的关系。抽象出来一个四边形接口(Quadrilateral)，让Rectangle类和Square类实现Quadrilateral接口
#### 依赖倒转原则
- 高层模块不应该依赖底层模块，两者都应该依赖其抽象；
- 抽象不应该依赖细节，细节应该依赖抽象。
- 简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。
- 案例：组装电脑
    - 分析：现要组装一台电脑，需要配件cpu、硬盘、内存条。只有这些配置都有了，计算机才能正常的运行。选择cpu有多选择，如Intel、AMD等，硬盘可以选择希捷，西数等，内存条可以选择金士顿，海盗船等。
    - 问题：代码可以看到已经组装了一台电脑，但是似乎组装的电脑cpu只能是Intel的，内存条只能是金士顿的，硬盘只能是希捷的，这对用户肯定是不太友好的，用户有了机箱肯定是想按照自己的喜好，选择自己喜欢的配件。
    - 改进：修改Computer类，让Computer类依赖抽象（各个配件的接口），而不是依赖于各个组件的具体实现类。
#### 接口隔离原则
- 客户端不应该被迫依赖于它不适用的方法；一个类对另一个类的依赖应该建立在最小的接口上。
- 案例：安全门案例
    - 分析：我们需要创建一个a品牌的安全门，该安全门具有防火、防水、防盗的功能。可以将防火、防水、防盗功能提取到一个接口。形成一套规范。
    - 问题：a品牌的安全门具有防盗，防水，防火的功能。现在如果我们还需要再创建一个b品牌的安全门，而该安全门只具有防盗、防水功能呢？很显然如果实现SafetyDoor接口就违背了接口隔离原则，那么我们如何进行修改呢？
    - 改进：将门的功能抽象为接口
#### 迪米特法则/单一职责原则

- 迪米特法则又叫最少知识原则。
- 只和你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。
- 如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。
- 迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。
- 案例：明星与经纪人的关系实例
  - 明星由于全身心投入艺术，所以许多日常事务由经纪人负责处理，如和粉丝的见面会，和媒体公司的业务洽淡等。这里的经纪人是明星的朋友，而粉丝和媒体公司是陌生人，所以适合使用迪米特法则。

#### 合成复用原则

- 尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。
- 通常类的复用分为继承复用和合成复用两种。
- 继承复用虽然有简单和易实现的优点，但它也存在以下缺点：
  - 继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。
  - 子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。
  - 它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。
- 采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点：
  - 它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。
  - 对象间的耦合度低。可以在类的成员位置声明抽象。
  - 复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。
- 案例：汽车分类管理程序
  - 汽车按“动力源”划分可分为汽油汽车、电动汽车等；按“颜色”划分可分为白色汽车、黑色汽车和红色汽车等。如果同时考虑这两种分类，其组合就很多。
  - 问题：继承复用产生了很多子类，如果现在又有新的动力源或者新的颜色的话，就需要再定义新的类。
  - 改进：将继承复用改为聚合复用看一下。